#! /bin/bash

# Created by Solomon Shorser
# Hacked by Denis Yuen
# Hacked by Brian O'Connor <briandoconnor@gmail.com>

# TODO:
# * we need a mechanism to shutdown since this script launches services in daemon mode

set -e

if [[ $EUID -ne 0 ]]; then
    echo "This script must be run as root" 1>&2
    exit 1
fi

cat <<MSG
UCSC CLOUD COMMONS INSTALLATION BOOTSTRAPPER
-----------------------------------------------------------------------------
This tool will setup a single host which has all of the infrastructure we
use to run the UCSC Cloud Commons reference implemenation used by the
UCSC Genomics Institute.  See https://github.com/DataBiosphere/dcc-ops

This system requires the following:
* Docker support in your Linux distribution (Ubuntu 16.04 is officially supported).
* AWS credentials, if you are using Amazon AWS.

Note: by default the ethernet device is assumed to be eth0 and this is used to
find the IP address of the host. In some instances on AWS the default ethernet
device is ens3 for example. You can override the eth0 by setting the
ETH_DEV env variable before running this script.

For more information see:

* the main GitHub page: https://github.com/DataBiosphere/dcc-ops
* the UCSC Genomics Institute - Analysis Core: http://ucsc-cgl.org

MSG

function generate_password {
    tr -cd '[:alnum:]' < /dev/urandom | fold -w30 | head -n1
}

# Ask the user a question and save the answer.
# They MUST give an answer, they cannot leave their answer blank. In the future, that could be parameterized...
# $1 - the question string
# $2 - the previous value
# $3 - the name of the value
# $4 - reference to the user's answer.
function ask_question()
{
  question_str=$1
  prev_val=$2
  val_name=$3
  answer=''

    while [[ -z ${answer// /} ]] ; do
        if [[ -n $prev_val ]] ; then
      read -ep "${question_str} Previous value: "$'\n' -i "$prev_val" answer
        else
            read -ep "$question_str"$'\n' answer
        fi
        if [[ -z ${answer// /} ]] ; then
            echo "$val_name name cannot be blank."
        fi
    done
    # Set the user's value in the reference. See here: http://stackoverflow.com/a/14852461/192801 to get an idea of how this works.
  eval "${!4}=\"$answer\""
}

# RUN BASIC INSTALLERS
# FYI: The weird "^^" is to make the user input into uppercase so that if they enter "y" the installer will still run.
install_commons_launcher=''
while [[ "${install_commons_launcher^^}" != 'Y' &&  "${install_commons_launcher^^}" != 'N' ]] ; do
  echo "DO YOU WISH TO CONTINUE [Y/N]:"
  read install_commons_launcher
  if [ "${install_commons_launcher^^}" = 'Y' ] ; then
    user_install_docker=''
    set +e
    DOCKER_PATH="$(which docker)"
    set -e
    if [ -z "$DOCKER_PATH" ] ; then
      user_install_docker='Y'
    else
      while [[ "${user_install_docker^^}" != 'Y' &&  "${user_install_docker^^}" != 'N' ]] ; do
        echo "It looks like docker may already be installed. Would you like to run this step anyway, which may attempt to upgrade docker? [Y/N]"
        read user_install_docker
      done
    fi

    echo "Installing various apt packages"
    # need to install regardless
    set +e
    sudo apt-get -y update 
    sudo apt-get install wget curl ruby-mustache=1.0.2-1 jq git --yes &> install_wget_curl.log
    install_wget_result=$?
    set -e

    if [ $install_wget_result -ne  0 ] ; then
      echo "It looks like there may have been a problem installing or updated wget and curl:"
      cat install_wget_curl.log
      exit 1
    fi

    if [ "${user_install_docker^^}" = 'Y' ] ; then
      # Remove eXecute permission from /etc/grub.d/30_os-prober because sometimes the docker installer will hang when this hangs. This has happened in OpenStack
      # and could happen elsewhere.
      if [ -f /etc/grub.d/30_os-prober ] ; then
        sudo chmod a-x /etc/grub.d/30_os-prober
      fi

      echo "Installing docker..."

      set +e
      curl -sSL https://get.docker.com/ | sh &> install_docker.log
      install_docker_result=$?
      set -e

      if [ $install_docker_result -ne  0 ] ; then
        echo "It looks like there may have been a problem installing docker:"
        cat install_wget_curl.log
        exit 1
      fi

      set +e
      sudo wget https://github.com/docker/compose/releases/download/1.8.1/run.sh -O /usr/local/bin/docker-compose && sudo chmod +x /usr/local/bin/docker-compose  &> install_compose.log
      install_compose_result=$?
      set -e

      if [ $install_compose_result -ne  0 ] ; then
        echo "It looks like there may have been a problem installing docker compose:"
        cat install_compose.log
        exit 1
      fi

      echo "Done installing docker!"
      DOCKER_PATH="$(which docker)"
    else
      echo "Skipping docker installation..."
    fi

    if [ -z "$DOCKER_PATH" ] ; then
      echo "You need to install docker before pulling docker images. Please ensure that docker is properly installed and then re-run this script with the command \"bash install_bootstrap\""
      exit 1
    fi
  elif [ "${install_commons_launcher^^}" = 'N' ] ; then
    echo "You are exiting the installer now, but you can always run it again when you are ready."
    exit 0
  fi
done

# CORE COMMONS: initial steps
if [[ $(sudo docker network ls | grep core_public | wc -l) = "0" ]]; then
    echo "creating core_public docker network"
    sudo docker network create core_public
else
    echo "core_public docker network already exists"
fi

# CORE COMMONS: setup elastic search network
if [[ $(sudo docker network ls | grep esnet | wc -l) = "0" ]]; then
    echo "creating esnet docker network"
    sudo docker network create esnet
else
    echo "esnet docker network already exists"
fi

#add the command to
#start the UCSC Computational Genomics Platform (CGP) container that sets up the
#Nginx config template with the uuids for each of the containers in the CGP
#at boot time
echo "Attempting to add docker start core-config-gen to rc.local"
sudo ./put_core_start_cmd_in_rc.sh

# CORE COMMON: bring up the primary nginx gateway server
run_common=''
while [[ "${run_common^^}" != 'Y' &&  "${run_common^^}" != 'N' ]] ; do
    read -ep $'Are you ready to launch the public-facing gateway nginx server? [Y/N]\n' run_common
done

if [[ "${run_common^^}" = 'Y' ]]; then
    if [[ $(sudo docker ps | grep 'core-' | wc -l) = "0" ]]; then
      echo "Do you want to run the public-facing gateway nginx server in dev mode or prod? [dev/prod]"
      common_mode=-1
      while [[ "${common_mode}" = "-1" ]]; do
            read common_mode
            if [[ "${common_mode^^}" =~ ^(D|DEV|DEVELOP|DEVELOPMENT)$ ]]; then
                common_mode=dev
            elif [[ "${common_mode^^}" =~ ^(P|PROD|PRODUCTION)$ ]]; then
                common_mode=prod
            else
                echo "bad input: ${common_mode}" >&2
                common_mode=-1
            fi
        done

        echo "starting core primary nginx gateway and common containers"
        cd common
        sudo docker-compose -f base.yml -f ${common_mode}.yml up -d
        cd ..
    else
        echo "core common containers already running."
    fi
    echo 'you can stop the core common containers with `cd $(pwd)/common && docker-compose -f base.yml -f prod.yml down`'
else
    echo "the core won't be publicly accessible until the gateway is started"
fi



# RUN THE BOARDWALK INSTALLER
run_boardwalk=''
while [[ "${run_boardwalk^^}" != 'Y' &&  "${run_boardwalk^^}" != 'N' ]] ; do
    echo "Would you like to run the boardwalk installer now? [Y/N]"
    read run_boardwalk

    if [ "${run_boardwalk^^}" = 'Y' ] ; then
      #Per ES specifications to run their docker image on production:
      #Set vm.max_map_count to 262144
      #Set the default elasticsearch1 service name
      es_service=elasticsearch1
      dcc_dashboard_protocol=https
      dcc_dashboard_port=8080
      echo "Setting max VM for ElasticSearch"
      sudo sysctl -w vm.max_map_count=262144
      sudo echo "vm.max_map_count=262144" >> /etc/sysctl.conf

      if [ -f boardwalk_launcher_config/boardwalk.config ] ; then
        	source <(jq -r "to_entries|map(\"\(.key)=\(.value|tostring)\")|.[]" boardwalk_launcher_config/boardwalk.config)
      fi

      echo "Do you want to run boardwalk in dev mode or prod? [dev/prod]"
      boardwalk_mode=-1
      while [[ "${boardwalk_mode}" = "-1" ]]; do
          read boardwalk_mode
          if [[ "${boardwalk_mode^^}" =~ ^(D|DEV|DEVELOP|DEVELOPMENT)$ ]]; then
              boardwalk_mode=dev
          elif [[ "${boardwalk_mode^^}" =~ ^(P|PROD|PRODUCTION)$ ]]; then
              boardwalk_mode=prod
          else
              echo "bad input: ${boardwalk_mode}" >&2
              boardwalk_mode=-1
          fi
      done

#      base_url=''
#      if [ ! -z $BASE_URL ] ; then
#            read -ep $'What is the name of the base URL?  Previous value: \n' -i "$BASE_URL" base_url
#         else
#            read -ep $'What is the name of the base URL? \n' base_url
#      fi

#      email_address=''
#            read -ep $'What is the email address for notification?  Previous value: \n' -i "$EMAIL_ADDRESS" email_address
#         else
#            read -ep $'What is the email address for notification? \n' email_address
#      fi

      google_client_id='google_client_id'
      ask_question "What is your Google Client ID?" "$GOOGLE_CLIENT_ID" "Google Client ID" $google_client_id

      google_client_secret='google_client_secret'
      ask_question "What is your Google Client Secret?" "$GOOGLE_CLIENT_SECRET" "Google Client Secret" $google_client_secret

      # redwood auth-server admin user - most probably always 'admin'
      # EDIT: The login function requires the mgmt user. admin wouldn't work.
      redwood_admin='mgmt'
      #ask_question "What is your Redwood auth-server admin username?" "$REDWOOD_ADMIN" "Redwood Admin" $redwood_admin

      # redwood auth-server admin password - peek at redwood/.env
      redwood_admin_password=$(cat redwood/.env | grep 'mgmt_client_secret=' | sed 's/[^=]*=//')
      #ask_question "What is your Redwood auth-server admin user password?" "$REDWOOD_ADMIN_PASSWORD" "Redwood Admin Password" $redwood_admin_password

      # redwood endpoint - peek at redwood/.env
      redwood_server=$(cat redwood/.env | grep 'base_url=' | sed 's/[^=]*=//')
      #ask_question "What is your Redwood endpoint?" "$REDWOOD_SERVER" "Redwood Server" $redwood_server

      # not really relevant anymore; always 443 (but have to use auth-server vhost)
      redwood_admin_port='443'
      #ask_question "What is your Redwood auth-server Admin Port?" "$REDWOOD_ADMIN_PORT" "Redwood Admin Port" $redwood_admin_port

      # generate redwood access token
      redwood_access_token=$(sudo redwood/cli/bin/redwood token create -u indexer -s 'aws.upload aws.download')
      #ask_question "What is your Redwood Access Token?" "$REDWOOD_ACCESS_TOKEN" "Redwood Access Token" $redwood_access_token

      #dcc_dashboard_host='dcc_dashboard_host'
      #ask_question "What is your DCC Dashboard Host (base URL)?" "$DCC_DASHBOARD_HOST" "DCC Dashboard Host" $dcc_dashboard_host
      dcc_dashboard_host=$redwood_server

#      dcc_dashboard_port='dcc_dashboard_port'
#      ask_question "What is your DCC Dashboard Port?" "$DCC_DASHBOARD_PORT" "DCC Dashboard Port" $dcc_dashboard_port

#      dcc_dashboard_protocol='dcc_dashboard_protocol'
#      ask_question "What is your DCC Dashboard Protocol (http/https)?" "$DCC_DASHBOARD_PROTOCOL" "DCC Dashboard Protocol" $dcc_dashboard_protocol

#      dcc_dashboard_service='dcc_dashboard_service'
#      ask_question "Where is your DCC Dashboard Service domain?" "$DCC_DASHBOARD_SERVICE" "DCC Dashboard Service" $dcc_dashboard_service

       dcc_dashboard_service=$dcc_dashboard_host

#      dcc_invoicing_service='dcc_invoicing_service'
#      ask_question "What is your DCC Invocing Service domain?" "$DCC_INVOICING_SERVICE" "DCC Invoicing Service" $dcc_invoicing_service

       dcc_invoicing_service=$dcc_dashboard_host

#      dcc_letsencrypt_staging='dcc_letsencrypt_staging'
#      ask_question "If you would like to add any additional flags to the Let's Encrypt image, such as --staging put the tags here." "$DCC_LETSENCRYPT_STAGING" "DCC Lets Encrypt tags" $dcc_letsencrypt_staging

      # this should move to the COMMON section
#      dcc_letsencrypt_email='dcc_letsencrypt_email'
#      ask_question "What is the email to be associated with the letsencrypt certificates?" "$DCC_LETSENCRYPT_EMAIL" "DCC Lets Encrypt Email" $dcc_letsencrypt_email

      #user_group='user_group'
      #ask_question "What is the user and group that should own the files from the metadata-indexer? (Your current USER:GROUP is $(stat -c '%u:%g' $HOME))" "$USER_GROUP" "User Group" $user_group
      user_group=$(stat -c '%u:%g' $HOME)

#      es_service='es_service'
#      ask_question "What will be the name for the elasticsearch service?" "$ES_SERVICE" "DCC Lets Encrypt tags" $es_service

#      database_url='database_url'
#      ask_question "What is the database url to store invoicing?" "$DATABASE_URL" "DCC Invoicing Database URL" $database_url

      #billing_db='billing_db'
      #ask_question "How should the database for billing should be called?" "$BILLING_DB" "Billing Database" $billing_db
      billing_db='billing_db'

      #billing_user='billing_user'
      #ask_question "What should the username be for the billing database?" "$BILLING_USER" "Billing User" $billing_user
      billing_user='billing_user'

      #billing_password='billing_password'
      #ask_question "What should the username password be for the billing database?" "$BILLING_PASSWORD" "Billing User Password" $billing_password
      echo "generating billing_db postgresql (postgres) password"
      billing_password="$(generate_password)"

      database_url="postgresql://${billing_user}:${billing_password}@boardwalk-billing:5432/${billing_db}"

      aws_profile='aws_profile'
      ask_question "What is the AWS profile?" "$AWS_PROFILE" "AWS Profile" $aws_profile
      #aws_profile=$(cat redwood/.env | grep 'email=' | sed 's/[^=]*=//')

      #aws_access_key_id='aws_access_key_id'
      #ask_question "What is the AWS Access key ID?" "$AWS_ACCESS_KEY_ID" "AWS Access key ID" $aws_access_key_id
      aws_access_key_id=$(cat redwood/.env | grep 'access_key=' | sed 's/[^=]*=//')   
 
      #aws_secret_access_key='aws_secret_access_key'
      #ask_question "What is the AWS secret access key?" "$AWS_SECRET_ACCESS_KEY" "AWS Secret Access Key" $aws_secret_access_key
      aws_secret_access_key=$(cat redwood/.env | grep 'secret_key=' | sed 's/[^=]*=//')

      #luigi_server='luigi_server'
      #ask_question "What is the Luigi Server?" "$LUIGI_SERVER" "Luigi Server" $luigi_server

      #postgres_db='postgres_db'
      #ask_question "What is the Postgres Database name for the action service?" "$POSTGRES_DB" "Postgres Database Action Service" $postgres_db
      postgres_db='monitor'      

      #postgres_user='postgres_user'
      #ask_question "What is the Postgres Database user for the action service?" "$POSTGRES_USER" "Postgres Database User Action Service" $postgres_user
      postgres_user='monitor'

      #postgres_password='postgres_password'
      #ask_question "What is the Postgres Database password for the action service?" "$POSTGRES_PASSWORD" "Postgres Database Password Action Service" $postgres_password
      echo "generating monitor postgresql (postgres) password"
      postgres_password="$(generate_password)"
      
      #Setting up the database vars for login 
      login_user='login-user'
      login_db='login-db'
      echo "generating monitor postgresql (postgres) password"
      login_password="$(generate_password)"      
      echo "generating SECRET_KEY for login"
      secret_key="$(generate_password)"

      echo "generating LOG_IN_TOKEN for boardwalk check session"
      login_token="$(generate_password)"
   
      #TODO: The script should snoop the .env file and check if it has a password assigned already and use that. Otherwise, generate a random password.
      core_client_version='1.1.2'
      # Now write a config for this file.
      [[ -f boardwalk_launcher_config/boardwalk.config ]] || mkdir -p boardwalk_launcher_config

      cat > boardwalk_launcher_config/boardwalk.config <<CONFIG
{
"GOOGLE_CLIENT_ID":"${google_client_id}",
"GOOGLE_CLIENT_SECRET":"${google_client_secret}",
"REDWOOD_ADMIN":"${redwood_admin}",
"REDWOOD_ADMIN_PASSWORD":"${redwood_admin_password}",
"REDWOOD_SERVER":"${redwood_server}",
"REDWOOD_ENDPOINT":"${redwood_server}",
"REDWOOD_ADMIN_PORT":"${redwood_admin_port}",
"DCC_DASHBOARD_HOST":"${dcc_dashboard_host}",
"DCC_DASHBOARD_PROTOCOL":"${dcc_dashboard_protocol}",
"REDWOOD_ACCESS_TOKEN":"${redwood_access_token}",
"DCC_DASHBOARD_SERVICE":"${dcc_dashboard_service}",
"DCC_INVOICING_SERVICE":"${dcc_invoicing_service}",
"DATABASE_URL":"${database_url}",
"BILLING_USER":"${billing_user}",
"BILLING_PASSWORD":"${billing_password}",
"BILLING_DB":"${billing_db}",
"USER_GROUP":"${user_group}",
"ES_SERVICE":"${es_service}",
"CONSONANCE_ADDRESS":"${consonance_address}",
"CONSONANCE_TOKEN":"${consonance_token}",
"AWS_PROFILE":"${aws_profile}",
"AWS_ACCESS_KEY_ID":"${aws_access_key_id}",
"AWS_SECRET_ACCESS_KEY":"${aws_secret_access_key}",
"POSTGRES_USER":"${postgres_user}",
"POSTGRES_PASSWORD":"${postgres_password}",
"POSTGRES_DB":"${postgres_db}",
"LOGIN_POSTGRES_USER":"${login_user}",
"LOGIN_POSTGRES_DB":"${login_db}",
"LOGIN_POSTGRES_PASSWORD":"${login_password}",
"SECRET_KEY":"${secret_key}",
"LOG_IN_TOKEN":"${login_token}",
"SERVER_NAME":"${dcc_dashboard_host}",
"DCC_CORE_CLIENT_VERSION":"${core_client_version}"
}
CONFIG
      # template out stuff
      mustache boardwalk_launcher_config/boardwalk.config boardwalk/conf/boardwalk.config.template > boardwalk/.env
      mustache boardwalk_launcher_config/boardwalk.config boardwalk/conf/aws.config.template > boardwalk/aws.config

      cd boardwalk
      #Bringing stuff down in case there are some cached containers
      echo "Bringing down any existing Boardwalk container and volumes"
      sudo docker-compose -f ${boardwalk_mode}.yml down -v
      echo "Creating Boardwalk associated containers"
      sudo docker-compose -f ${boardwalk_mode}.yml up -d
      cd ..

   elif [ "${run_boardwalk^^}" = 'N' ] ; then
      echo "You can run this script at another time to run the boardwalk installer"
   fi
done


# FINISHED INSTALLER
echo "Done with installation, exiting now."
set +e
